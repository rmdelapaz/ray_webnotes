
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursion Basics in JavaScript</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Understanding the Basics of Recursion in JavaScript</h1>
        <p>A Guide for New Developers with Real-World Examples and Analogies</p>
    </header>

    <section>
        <h2>What is Recursion?</h2>
        <p><strong>Analogy:</strong> Imagine standing between two mirrors facing each other. The reflection repeats infinitely, creating smaller and smaller versions of the original image. Recursion in programming is similar: a function calls itself to solve smaller instances of the same problem, getting closer to the solution with each step.</p>
    </section>

    <section>
        <h2>How Recursion Works</h2>
        <p>Recursion occurs when a function calls itself during its execution. This continues until a stopping condition, known as the base case, is met.</p>
        <pre><code>function countDown(n) {
    if (n === 0) {  // Base case
        console.log("Done!");
        return;
    }
    console.log(n);
    countDown(n - 1);  // Recursive case
}

countDown(5);  // Output: 5, 4, 3, 2, 1, Done!
</code></pre>
        <p>In this example, the function <code>countDown</code> prints numbers from <code>n</code> down to 1, then prints "Done!" once <code>n</code> reaches 0 (the base case).</p>
    </section>

    <section>
        <h2>Base Case and Recursive Case</h2>
        <p>Every recursive function has two parts:</p>
        <ul>
            <li><strong>Base Case:</strong> The condition that stops the recursion.</li>
            <li><strong>Recursive Case:</strong> The part where the function calls itself with a smaller or simpler input.</li>
        </ul>
        <p><strong>Metaphor:</strong> Think of recursion like a set of nesting dolls. Each doll represents a smaller version of the problem, and the base case is the smallest doll that cannot be opened further.</p>
    </section>

    <section>
        <h2>Common Uses of Recursion</h2>
        <ul>
            <li><strong>Calculating Factorials:</strong> Factorials are the product of all integers from 1 to <code>n</code>. Recursion is a natural fit for calculating them.</li>
            <pre><code>function factorial(n) {
    if (n === 1) {  // Base case
        return 1;
    }
    return n * factorial(n - 1);  // Recursive case
}

console.log(factorial(5));  // Output: 120
</code></pre>
            <li><strong>Traversing Data Structures:</strong> Recursion is commonly used to navigate tree-like structures, such as directories or file systems.</li>
        </ul>
    </section>

    <section>
        <h2>Why Use Recursion?</h2>
        <p>Recursion simplifies problems that can be broken down into smaller, similar problems. It provides a clean and elegant solution to many complex problems, especially in algorithms and data structures.</p>
        <p>However, it’s important to use recursion carefully to avoid issues like stack overflow, which occurs when the recursion goes too deep without hitting a base case.</p>
    </section>

    <section>
        <h2>Real-World Example: Recursive Directory Traversal</h2>
        <p>Imagine trying to list all the files in a folder, including files inside subfolders. This problem can be naturally solved using recursion:</p>
        <pre><code>function listFiles(directory) {
    console.log(directory.name);

    for (let file of directory.files) {
        if (file.isDirectory) {
            listFiles(file);  // Recursive call for subfolders
        } else {
            console.log(file.name);  // Base case: list the file
        }
    }
}

// Example directory structure
const myFolder = {
    name: 'Main Folder',
    files: [
        { name: 'file1.txt', isDirectory: false },
        { name: 'file2.txt', isDirectory: false },
        {
            name: 'Subfolder',
            isDirectory: true,
            files: [
                { name: 'file3.txt', isDirectory: false }
            ]
        }
    ]
};

listFiles(myFolder);
</code></pre>
        <p>This function traverses through all files and subfolders, printing their names recursively.</p>
    </section>

    <section>
        <h2>Best Practices for Recursion</h2>
        <ul>
            <li><strong>Always Define a Base Case:</strong> Ensure your recursive function has a stopping condition to prevent infinite recursion.</li>
            <li><strong>Think in Smaller Steps:</strong> Break down the problem into smaller subproblems that can be solved recursively.</li>
            <li><strong>Test with Small Inputs:</strong> Test your recursive function with simple inputs to verify that it works correctly and doesn’t lead to a stack overflow.</li>
        </ul>
    </section>

    <footer>
        <p>Further Learning: Explore how recursion is used in sorting algorithms like quicksort and mergesort, and how it can be optimized using techniques like memoization.</p>
    </footer>
</body>
</html>
