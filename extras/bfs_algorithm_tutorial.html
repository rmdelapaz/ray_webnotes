
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breadth-First Search (BFS) Explained</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png" type="image/png">
</head>
<body>
    <h1>Understanding Breadth-First Search (BFS) in JavaScript</h1>

    <p>In this tutorial, we’ll explore a common graph traversal algorithm known as <strong>Breadth-First Search (BFS)</strong>. BFS is widely used in various applications, especially in finding the shortest path in unweighted graphs. Let's break it down and understand its implementation step by step.</p>

    <h2>What is Breadth-First Search?</h2>
    <p>Breadth-First Search (BFS) is an algorithm for traversing or searching through graph or tree structures. It starts from a selected node (often called the root in trees) and explores all neighboring nodes at the current depth before moving on to nodes at the next depth level. BFS works like exploring a map by first visiting all locations that are closest to you, then expanding outward.</p>

    <h2>When and Why to Use BFS?</h2>
    <p>BFS is especially useful when we need to find the shortest path in unweighted graphs or explore all possible paths in a systematic manner. BFS ensures that all nodes at the same level (distance from the starting point) are processed before moving on to the next level, making it ideal for problems like:</p>
    <ul>
        <li>Finding the shortest path in a maze or grid</li>
        <li>Solving puzzles where each move leads to a new state</li>
        <li>Finding the connected components in a graph</li>
    </ul>

    <h2>BFS Code Example</h2>
    <p>Below is an example of how to implement BFS in JavaScript using a graph represented as an adjacency list:</p>

    <pre>
        <code>
            function bfs(graph, start) {
                let visited = new Set(); // Track visited nodes
                let queue = [start]; // Initialize the queue with the starting node
                visited.add(start);

                while (queue.length > 0) {
                    let node = queue.shift(); // Dequeue the front node
                    console.log(node); // Process the node (here, we print it)

                    // Get all neighbors of the current node
                    let neighbors = graph[node];

                    // For each neighbor, if it's not visited, enqueue it and mark as visited
                    for (let neighbor of neighbors) {
                        if (!visited.has(neighbor)) {
                            queue.push(neighbor);
                            visited.add(neighbor);
                        }
                    }
                }
            }

            // Example graph represented as an adjacency list
            let graph = {
                A: ['B', 'C'],
                B: ['A', 'D', 'E'],
                C: ['A', 'F'],
                D: ['B'],
                E: ['B', 'F'],
                F: ['C', 'E']
            };

            // Start BFS from node 'A'
            bfs(graph, 'A');
        </code>
    </pre>

    <h2>Code Explanation</h2>

    <p>Let’s break down the code step by step:</p>

    <h3>1. The Graph Representation</h3>
    <p>The graph is represented using an <strong>adjacency list</strong>, where each node has a list of neighbors:</p>
    <pre><code>let graph = { A: ['B', 'C'], B: ['A', 'D', 'E'], C: ['A', 'F'], D: ['B'], E: ['B', 'F'], F: ['C', 'E'] };</code></pre>
    <p>This means node A is connected to nodes B and C, node B is connected to A, D, and E, and so on.</p>

    <h3>2. Initializing BFS</h3>
    <p>We begin BFS by adding the starting node (A) to the queue:</p>
    <pre><code>let queue = [start];</code></pre>
    <p>We also track which nodes we’ve visited using a <strong>Set</strong> to avoid processing the same node multiple times:</p>
    <pre><code>let visited = new Set(); visited.add(start);</code></pre>

    <h3>3. Traversing the Graph</h3>
    <p>We enter a <code>while</code> loop that continues until there are no more nodes in the queue:</p>
    <pre><code>while (queue.length > 0) { let node = queue.shift(); console.log(node); }</code></pre>
    <p>Each time, we <strong>dequeue</strong> the front node, process it (in this case, we print it), and check all its neighbors.</p>

    <h3>4. Visiting Neighbors</h3>
    <p>For each neighbor of the current node, we check if it has been visited:</p>
    <pre><code>if (!visited.has(neighbor)) { queue.push(neighbor); visited.add(neighbor); }</code></pre>
    <p>If not, we add it to the queue and mark it as visited. This ensures we process the closest nodes first before moving to nodes further away.</p>

    <h2>Real-World Example and Applications</h2>
    <p>Imagine BFS as exploring all rooms in a building. You start at the entrance and explore all nearby rooms first. Once those are explored, you move to the next set of rooms connected to the ones you've already visited. BFS is used in real-world applications such as:</p>
    <ul>
        <li><strong>Shortest Path Finding:</strong> In GPS systems or maps, BFS can be used to find the shortest path between two locations.</li>
        <li><strong>Social Networks:</strong> BFS can be used to find the shortest connection between two people in a social network.</li>
        <li><strong>Web Crawlers:</strong> Web crawlers can use BFS to explore links on a website layer by layer.</li>
    </ul>

    <h2>Further Exploration</h2>
    <p>Once you’re comfortable with BFS, you might want to explore:</p>
    <ul>
        <li><strong>Depth-First Search (DFS):</strong> Another common graph traversal algorithm that explores nodes deeper in the graph first.</li>
        <li><strong>Dijkstra's Algorithm:</strong> A pathfinding algorithm that works similarly to BFS but takes edge weights into account.</li>
        <li><strong>A* Algorithm:</strong> An advanced pathfinding algorithm often used in AI and games.</li>
    </ul>

    <h2>Conclusion</h2>
    <p>Breadth-First Search is a powerful graph traversal technique that explores all neighbors at the current depth before moving on to deeper nodes. It’s widely used in applications where finding the shortest path or exploring nodes systematically is required. Once you understand BFS, you’ll have a solid foundation for tackling more advanced graph algorithms.</p>

</body>
</html>
