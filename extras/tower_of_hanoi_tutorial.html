
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Using Recursion to Solve Tower of Hanoi</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png" type="image/png">
</head>
<body>
    <header>
        <h1>Using Recursion to Solve Tower of Hanoi</h1>
  
    </header>

    <section>
        <h2>Introduction</h2>
        <p>
            The Tower of Hanoi is a classic problem that helps to understand the concept of recursion in programming. 
            It involves moving a set of rings from one rod to another, following specific rules. 
            In this tutorial, we'll learn how to solve the Tower of Hanoi using recursion, and we'll explore how recursion 
            makes it easier to manage problems that involve repeating a task in a structured way.
        </p>
        <p>
            We'll cover the basics of recursion, dive into the Tower of Hanoi problem, and implement a solution using 
            recursive techniques. We'll use analogies, real-world examples, and code snippets to deepen your understanding 
            of recursion and how it can simplify complex problems.
        </p>
    </section>

    <section>
        <h2>Understanding Recursion</h2>
        <p>
            Recursion is a process where a function calls itself in order to solve a problem. This technique is particularly 
            useful when a problem can be broken down into smaller, similar sub-problems. Each recursive call should bring 
            you closer to a "base case," which is the simplest instance of the problem that can be solved directly without 
            further recursion.
        </p>
        <p>
            <strong>Analogy:</strong> Imagine a line of people passing a message down the line. Each person passes it to the 
            next, and the message is delivered step by step. Recursion works in a similar way — each function call hands 
            off part of the problem to the next, until it reaches the base case and the answers are passed back up the line.
        </p>
    </section>

    <section>
        <h2>The Tower of Hanoi Problem</h2>
        <p>
            The Tower of Hanoi consists of three rods and a number of rings of different sizes. The objective is to move 
            all the rings from one rod (the source) to another rod (the destination) using an auxiliary rod, while following 
            these rules:
        </p>
        <ul>
            <li>Only one ring can be moved at a time.</li>
            <li>A ring can only be moved if it is the top ring on a rod.</li>
            <li>No larger ring can be placed on top of a smaller ring.</li>
        </ul>
        <p>
            The goal is to move all the rings from the source rod to the destination rod, using the auxiliary rod as needed.
        </p>
    </section>

    <section>
        <h2>How Recursion Solves the Tower of Hanoi</h2>
        <p>
            Recursion is an ideal technique for solving the Tower of Hanoi because the process of moving <em>n</em> rings 
            can be broken down into smaller tasks of moving fewer rings. Here’s the thought process:
        </p>
        <blockquote>
            If you can move <em>n - 1</em> rings from the source rod to the auxiliary rod, you can then move the 
            <strong>largest ring</strong> directly to the destination rod. After that, you can move the <em>n - 1</em> 
            rings from the auxiliary rod to the destination rod.
        </blockquote>

        <h3>Recursive Solution</h3>
        <p>Here’s the recursive algorithm:</p>
        <ol>
            <li>Move <em>n - 1</em> rings from the source rod to the auxiliary rod.</li>
            <li>Move the largest ring (ring <em>n</em>) from the source rod to the destination rod.</li>
            <li>Move the <em>n - 1</em> rings from the auxiliary rod to the destination rod.</li>
        </ol>

        <pre><code>
// Recursive function to solve Tower of Hanoi
function towerOfHanoi(n, source, destination, auxiliary) {
    if (n === 1) {
        console.log(`Move ring 1 from ${source} to ${destination}`);
        return;
    }

    // Move n-1 rings from source to auxiliary, so they are out of the way
    towerOfHanoi(n - 1, source, auxiliary, destination);

    // Move the nth ring from source to destination
    console.log(`Move ring ${n} from ${source} to ${destination}`);

    // Move the n-1 rings from auxiliary to destination
    towerOfHanoi(n - 1, auxiliary, destination, source);
}

// Example usage: solve for 3 rings
towerOfHanoi(3, 'A', 'C', 'B');
        </code></pre>

        <p>
            In this example, the function calls itself to move <em>n - 1</em> rings, then moves the nth ring, and finally 
            calls itself again to move the <em>n - 1</em> rings to their final position. This recursive approach 
            elegantly handles the task, regardless of how many rings there are.
        </p>
    </section>

    <section>
        <h2>Real-World Applications of Recursion</h2>
        <p>
            Recursion is not just for puzzles like the Tower of Hanoi. It’s also used in various real-world scenarios:
        </p>
        <ul>
            <li>Searching through file systems where each directory can contain more directories (tree structures).</li>
            <li>Solving complex mathematical problems like factorial calculations and Fibonacci sequences.</li>
            <li>Parsing nested data, such as JSON structures or XML documents.</li>
        </ul>
        <p>
            <strong>When to Use Recursion:</strong> Recursion is best used when a problem can be divided into smaller, 
            similar problems. However, be cautious — recursion can lead to performance issues if not implemented carefully, 
            especially if there’s no clear base case.
        </p>
    </section>

    <section>
        <h2>Exploring Further: Visualizing Recursion</h2>
        <p>
            Understanding recursion can be challenging, but visualizing how each function call stacks up can be immensely 
            helpful. Think of each recursive call as a plate being stacked on top of another plate. Each plate represents 
            a function call waiting to complete. When a base case is reached, the plates start to be removed, one by one, 
            until all are processed.
        </p>
        <p>
            For deeper learning, try visualizing the recursive calls for different numbers of rings. Observe how the problem 
            scales as the number of rings increases, and how the recursive solution handles each step.
        </p>
    </section>

    <footer>
        <p>&copy; 2024 JavaScript Tutorials for Beginners</p>
    </footer>
</body>
</html>
